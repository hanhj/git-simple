数组 指针 数组传递
    指针是一个数，其内容是一个地址，可以说指针指向一个地址。这个地址存放的是一个数，或是一个数组（连续的数，数组名代表这个地址,数组名带下标代表其中的数）。
	例如：
	int *p;
	int data;
	int array[]={1,2,3...};
	p=array;
	data=array[1];
	p=&array[0];与p=array是等效的，因为array代表地址，而&array[0]表示取第一个元素的地址。
	所以说 “指针与一维数组是等效的”。
	在函数中传递一个数组，为了高效可以用指针（因为传值需要复制，低效）
	void foo(int *p){
		p[0]=3;
		*(p+1)=3;
		...
	}
	or
	void foo1(int p[]){
		p[1]=3;	
		...
	}
	int main(){
		foo(array);	or foo(&array[0]);
		...
		foo1(array);or foo1(&array[0]);	
	}

    指针的指针（二重指针），也指向一个地址，该地址存放的是一个指针，或是一个指针数组（连续的指针构成的数组，数组名代表这个指针数组的地址，数组名带下标代表该指针数组中的某个指针）。
	例如：
	int *q[2];//指针数组
	int array[][2]={{1,2},{3,4}};
	q[0]=array[0];//array[0]是指向array第一行数组的指针
	q[1]=array[1];//array[0]是指向array第二行数组的指针
	int **P;
	p=q;//p是指向指针数组q的指针。
	or p=&q[0];
	二重指针等同于指针数组，但是只能有限的等同于二维数组。
	因为二重指针要求所指向的是一个指针数组，既是数组就要求其内部值是连续的，即其内部指针是连续存放的。而二维数组中每一行数组的起始地址并不是不连续的，所以不能直接将二维数组地址传递给二重指针。如果想把二维数组传递给一个二重指针，需要首先构建一个指针数组。
	void foo(int **p){
		p[0][0]=3;
	}
	int **p;
	int *q[2];
	int array[][2]={{1,2},{3,4}};
	int main(){
		q[0]=array[0];
		q[1]=array[1];
		p=q;
		foo(p);
	}
	
	那么如何不用构建指针数组来讲二维数组传递给一个函数？
	用一维数组。
	void foo(int p[][2]){//p是一个每行有两个元素的数组
		p[0][0]=3;
	}
	foo(array);
	即当传递二维数组到函数时，需要在函数的形参中指明下一阶的个数。
	这时就不能用二重指针:
	void foo(int **p){
		...
	}
	foo(array);//将编译出错

	那么什么叫二重指针有限的等同于二维数组？
	通常是用于动态构建二维数组的时候，例如：
	int **p;
	p=new int *[2];//先分配两个指针
	p[0]=new int[2];//为每个指针再分配空间，p[0]相当于第一行数组的指针
	p[1]=new int[2];//p[1]是第二行数组的指针。
	此时就可以用p[i][j]来访问了。

	总之，如果在程序中使用二重指针，需要将其指向一个指针数组或是一个指针。

